package com.imp3.Backend.tag;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.imp3.Backend.common.GeminiService;
import com.imp3.Backend.common.SpotifyService;
import com.imp3.Backend.user.User;
import com.imp3.Backend.user.UserRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class TagService {

    private final UserTagRepository usertagrepository;
    private final TagRepository tagrepository;
    private final UserRepository userrepository;
    private final SpotifyService spotifyservice;
    private final GeminiService geminiservice;

    /**
     * Generates tags for a user based on their Spotify listening history.
     * Pulls top artists and extracts genres to create auto-generated tags.
     * @param user to generate tags for
     * @return list of newly created UserTags
     */
    @Transactional
    public List<UserTag> generateTagsFromSpotify(User user){
        if(user.getSpotifyAccessToken() == null || user.getSpotifyAccessToken().isBlank()) {
            log.warn("User {} has no Spotify token linked", user.getId());
            return List.of();
        }

        List<String> artistNames = new ArrayList<>();
        List<String> trackNames = new ArrayList<>();
        Set<String> genres = new HashSet<>();


        try {
            JsonNode topArtists = spotifyservice.getUserTopArtists(user);

            if(topArtists != null && topArtists.isArray()){
                for(JsonNode artist : topArtists){
                    artistNames.add(artist.get("name").asText());
                    if(artist.has("genres")){
                        for(JsonNode genre : artist.get("genres")){
                            genres.add(genre.asText().toLowerCase().trim());
                        }
                    }
                }
            }
        } catch (Exception e){
            log.warn("Failed to fetch top artists for user: {} {}", user.getId(), e.getMessage());
        }

        //fetch top tracks and extract genres from their artists
        try {
            JsonNode topTracks = spotifyservice.getUserTopTracks(user);

            if(topTracks != null && topTracks.isArray()){
                for(JsonNode track : topTracks){
                    trackNames.add(track.get("name").asText());
                }
            }
        } catch (Exception e) {
            log.warn("Failed to fetch top tracks for user {} : {}", user.getId(), e.getMessage());
        }

        //nothing to work with
        if(genres.isEmpty() && artistNames.isEmpty()){
            return List.of();
        }

        //use Gemini to create meaningful tags
        List<String> tagNames = generateTagsWithGemini(genres, artistNames, trackNames);

        //create UserTag entities
        List<UserTag> createdTags = new ArrayList<>();
        for(String tagName : tagNames ){

            Tag globalTag = tagrepository.findByName(tagName)
                    .orElseGet(() -> tagrepository.save(new Tag(tagName, Tag.TagCategory.OTHER)));

            //skip if user already has this tag
            if(usertagrepository.existsByUserAndTag(user, globalTag)){
                continue;
            }

            UserTag u = new UserTag(user, globalTag, UserTag.TagType.AUTO);
            u.setSource("Spotify");
            createdTags.add(usertagrepository.save(u));
        }


        return createdTags;

    }

    /**
     *  Generate new tags using the user's Spotify top genre/artist/track data
     *  Tags generated by gemini
     * @param genres top genres in user's listening history
     * @param artists top artists in user's listening history
     * @param tracks top tracks in user's listening history
     * @return list of tags
     */
    private List<String> generateTagsWithGemini(Set<String> genres, List<String> artists, List<String> tracks) {
        String prompt = """
        Based on this Spotify listening data, generate 5-8 short, vibe-based profile tags.
        Tags should be 2-4 words, lowercase, describing music personality (not just genre names).
        
        Examples of good tags: "late night driver", "indie coffee shop", "gym hype beast", "sad girl autumn"
        Examples of bad tags: "pop", "rock", "hip-hop" (too generic)
        
        Genres: %s
        Top Artists: %s
        Top Tracks: %s
        
        Return ONLY a JSON array of strings, nothing else.
        """.formatted(
                String.join(", ", genres),
                String.join(", ", artists.subList(0, Math.min(10, artists.size()))),
                String.join(", ", tracks.subList(0, Math.min(10, tracks.size())))
        );

        try {
            String response = geminiservice.generate(prompt);
            // Parse JSON array from response
            return parseTagsFromResponse(response);
        } catch (Exception e) {
            log.warn("Gemini tag generation failed: {}", e.getMessage());
            return List.of();
        }
    }

    /**
     * Parse JSON response from Gemini (clean up)
     * @param response to clean up
     * @return cleaned response
     */
    public List<String> parseTagsFromResponse(String response){
        try {
            //clean up response in case Gemini wraps it in markdown
            String cleaned = response.trim();
            if(cleaned.startsWith("```json")){
                cleaned = cleaned.substring(7);
            }
            if(cleaned.startsWith("```")){
                cleaned = cleaned.substring(3);
            }
            if(cleaned.endsWith("```")){
                cleaned = cleaned.substring(0, cleaned.length() - 3);
            }

            cleaned = cleaned.trim();

            //parse JSON array
            ObjectMapper mapper= new ObjectMapper();
            JsonNode array = mapper.readTree(cleaned);

            List<String> tags = new ArrayList<>();
            if(array.isArray()){
                for(JsonNode node : array){
                    String tag = node.asText().toLowerCase().trim();
                    if(!tag.isBlank() && tag.length() <= 50){
                        tags.add(tag);
                    }
                }
            }

            return tags;
        } catch (Exception e) {
            log.warn("Failed to parse Gemini response: {}", e.getMessage());
            return List.of();
        }
    }

    /**
     * Generates a profile summary for a user based on their tags using Gemini
     * @param uid the user's ID
     * @return generated summary string
     */
    public String generateProfileSummary(Integer uid){
        List<UserTag> u = usertagrepository.findByUser_Id(uid);

        if(u.isEmpty()){
            return "This user hasn't added any music tags yet.";
        }

        //extract tag names
        List<String> tagNames = u.stream()
                .map(ut -> ut.getTag().getName())
                .collect(Collectors.toList());

        String tagList = String.join(",", tagNames);

        String prompt = "Based on these music genre tags: [" + tagList + "], " +
                "write a brief 2-3 sentence profile summary describing this person's music taste." +
                "Be creative and conversational. Do not use bullet points.";

        String summary = geminiservice.generate(prompt);

        //clean up response
        summary = summary.replace("\\\"", "\"")
                .replace("\\n", " ")
                .replace("\\", "")
                .trim();

        return summary;

    }


}
