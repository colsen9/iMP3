package com.imp3.Backend.recommendation;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.imp3.Backend.common.AbstractController;
import com.imp3.Backend.common.GeminiService;
import com.imp3.Backend.common.SpotifyImportService;
import com.imp3.Backend.common.SpotifyService;
import com.imp3.Backend.music.Album;
import com.imp3.Backend.music.Artist;
import com.imp3.Backend.music.Track;
import com.imp3.Backend.music.TrackRepository;
import com.imp3.Backend.notification.NotificationService;
import com.imp3.Backend.user.User;
import com.imp3.Backend.user.UserRepository;
import jakarta.servlet.http.HttpSession;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;

import java.util.List;

@RestController
@RequestMapping("/rec")
public class RecController extends AbstractController {

    @Autowired
    RecRepository recrepository;

    @Autowired
    GeminiService geminiservice;

    @Autowired
    SpotifyService spotifyservice;

    @Autowired
    UserRepository userrepository;

    @Autowired
    TrackRepository trackrepository;

    @Autowired
    RecService recservice;

    @Autowired
    NotificationService notificationservice;

    @Autowired
    private SpotifyImportService spotifyimportservice;

    @Autowired
    private ObjectMapper objectmapper;

    /**
     *  CREATE (POST) - Creates a manual recommendation for a specific item
     *  the user already picked
     * @param recReq details of the recommendation to create
     * @param session containing "uid"
     * @return the saved Recommendation entity
     */
    @PostMapping
    public Recommendation createRecommendation(@RequestBody RecRequest recReq, HttpSession session){
        Integer uid = getSessionUid(session);

        //handle Spotify data first -- creates item if needed
        if(recReq.getSpotifyData() != null &&  recReq.getItemId() == null){
            try {
                JsonNode spotifyJson = objectmapper.readTree(recReq.getSpotifyData());

                switch(recReq.getType().toLowerCase()){
                    case "track":
                        Track track = spotifyimportservice.getOrCreateTrack(spotifyJson);
                        recReq.setItemId(String.valueOf(track.getId()));
                        if(recReq.getTitle() == null){
                            recReq.setTitle(track.getName());
                        }
                        break;
                    case "album":
                        Album album = spotifyimportservice.getOrCreateAlbum(spotifyJson);
                        recReq.setItemId(String.valueOf(album.getId()));
                        if(recReq.getTitle() == null){
                            recReq.setTitle(album.getName());
                        }
                        break;

                    case "artist":
                        Artist artist = spotifyimportservice.getOrCreateArtist(
                                spotifyJson.get("id").asText(),
                                spotifyJson.get("name").asText());
                        recReq.setItemId(String.valueOf(artist.getId()));
                        if(recReq.getTitle() == null){
                            recReq.setTitle(artist.getName());
                        }
                        break;
                    default:
                        throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Invalid type: " + recReq.getType());
                }
            } catch (JsonProcessingException e){
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Invalid Spotify data JSON");
            }
        }

        //validate required fields
        if(recReq.getType() == null || recReq.getItemId() == null || recReq.getTitle() == null){
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Missing required fields");
        }

        //Sets as user's own uid if made/generated by user
        Integer recipientUid = recReq.getRecipientUid() != null
                ? recReq.getRecipientUid() : uid;

        //verify recipient exists if sending to someone else
        if(!recipientUid.equals(uid)){
            userrepository.findById(recipientUid)
                    .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Recipient user not found"));
        }

        Recommendation r = new Recommendation();
        r.setSenderUid(uid);
        r.setRecipientUid(recipientUid);
        r.setType(recReq.getType());
        r.setTitle(recReq.getTitle());
        r.setItemId(recReq.getItemId());

        if(recReq.getPrivacy() != null){
            r.setPrivacy(recReq.getPrivacy());
        }

        if(recReq.getRationale() != null){
            r.setRationale(recReq.getRationale());
            r.setSource(Recommendation.RecSource.USER_WRITTEN);
        } else if("track".equalsIgnoreCase(recReq.getType())){
            Track track = trackrepository.findById(Integer.parseInt(recReq.getItemId()))
                    .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Track not found"));
            fillRationaleFromGemini(r, track.getSpotifyId());
        } else {
            // For albums/artists, set a default or skip Gemini
            r.setRationale("Check out this recommendation!");
            r.setSource(Recommendation.RecSource.USER_WRITTEN);
        }

        Recommendation saved = recrepository.save(r);

        if(!uid.equals(recipientUid)) {
            User sender = userrepository.findById(uid)
                    .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Sender not found"));
            User recipient = userrepository.findById(recipientUid).get();
            notificationservice.notifyUserRecommendation(sender, recipient, saved.getTitle() );
        }

        return saved;
    }

    /**
     * LIST (GET) - Gets all recommendations for the logged-in user
     * @param session containing "uid"
     * @return all recommendations for the logged-in user
     */
    @GetMapping
    public List<Recommendation> getAllRecommendations(HttpSession session){
        Integer uid = getSessionUid(session);

        //will return empty list if no recs exist
        return recrepository.findAllByRecipientUid(uid);
    }

    /**
     * LIST (GET) - Gets PUBLIC recommendations for a specific user
     * Used for viewing other people's profiles
     * @param profileUid the user whose rec to view
     * @param session containing "uid"
     * @return only PUBLIC recommendations for the specified user
     */
    @GetMapping("/users/{profileUid}")
    public List<Recommendation> getUserPublicRecommendations(@PathVariable Integer profileUid, HttpSession session){
        Integer uid = getSessionUid(session);

        //if somehow viewing your own profile via this endpoint, redirect logic
        if(profileUid.equals(uid)){
            return recrepository.findAllByRecipientUid(profileUid);
        }

        //viewing someone else's profile
        return recrepository.findAllByRecipientUidAndPrivacy(profileUid, Recommendation.Privacy.PUBLIC);
    }


    /**
     * READ (GET) - Get one specific recommendation for logged-in user
     * @param recId of the recommendation
     * @param session containing "uid"
     * @return recommendation by id
     */
    @GetMapping("/{recId}")
    public Recommendation getRecommendation(@PathVariable Integer recId, HttpSession session){
        Integer uid = getSessionUid(session);

        return recrepository.findByRecIdAndRecipientUid(recId, uid).
                orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND));
    }

    /**
     *  UPDATE (PUT) - Updates a recommendation for the logged-in user
     * @param recId of the recommendation
     * @param recReq details of the recommendation to update
     * @param session containing "uid"
     * @return the updated recommendation
     */
    @PutMapping("/{recId}")
    public Recommendation updateRecommendation(@PathVariable Integer recId,
                                               @RequestBody RecRequest recReq, HttpSession session){
        Integer uid =  getSessionUid(session);

        Recommendation r = recrepository.findByRecIdAndRecipientUid(recId, uid).
                orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND));

        if(recReq.getType() == null && recReq.getItemId() == null
                && recReq.getTitle() == null && recReq.getRationale() == null && recReq.getPrivacy() == null){
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "No fields provided to update");
        }

        if(recReq.getType() != null){
            r.setType(recReq.getType());
        }

        if(recReq.getItemId() != null){
            r.setItemId(recReq.getItemId());
        }

        if(recReq.getTitle() != null){
            r.setTitle(recReq.getTitle());
        }

        if(recReq.getPrivacy() != null){
            r.setPrivacy(recReq.getPrivacy());
        }

        if(recReq.getRationale() != null){
            r.setRationale(recReq.getRationale());
            r.setSource(Recommendation.RecSource.USER_WRITTEN);
        } else if ("track".equalsIgnoreCase(r.getType()) && (recReq.getItemId() != null || r.getItemId() != null)){
            String itemId = recReq.getItemId() != null ? recReq.getItemId() : r.getItemId();

            Track track = trackrepository.findById(Integer.parseInt(itemId))
                    .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Track not found"));

            fillRationaleFromGemini(r, track.getSpotifyId());
        }

        return recrepository.save(r);

    }

    /**
     * DELETE (DELETE) - Deletes a recommendation for logged-in user
     * @param recId of the recommendation
     * @param session containing "uid" d
     */
    @DeleteMapping("/{recId}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void deleteRecommendation(@PathVariable Integer recId, HttpSession session){
        Integer uid = getSessionUid(session);

        Recommendation r = recrepository.findByRecIdAndRecipientUid(recId, uid).
                orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND));

        recrepository.delete(r);
    }

    /**
     * READ (GET) = Get Spotify track data for a specific recommendation
     * @param recId id of the recommendation
     * @param session containing "uid"
     * @return raw Spotify track JSON from Spotify API
     */
    @GetMapping("/{recId}/spotify")
    public com.fasterxml.jackson.databind.JsonNode getRecommendationSpotify(@PathVariable Integer recId,
                                                                            HttpSession session){
        Integer uid = getSessionUid(session);

        Recommendation r = recrepository.findByRecIdAndRecipientUid(recId, uid).
                orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND));

        String itemId = r.getItemId();
        if(itemId == null){
            throw new ResponseStatusException(HttpStatus.UNPROCESSABLE_ENTITY, "Recommendation has no linked Spotify item id");
        }

         try {
             // Look up track to get Spotify ID
             Track track = trackrepository.findById(Integer.parseInt(itemId))
                     .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Track not found"));

             return spotifyservice.getTrack(track.getSpotifyId());
         } catch(IllegalStateException e){
             throw new ResponseStatusException(HttpStatus.BAD_GATEWAY, "Failed to fetch track from spotify: " + e.getMessage());
         }
    }

    /**
     * Helper method for generating rationale from Gemini
     * @param r recommendation to add rationale
     * @param spotifyId of the track to describe
     */
    private void fillRationaleFromGemini(Recommendation r, String spotifyId){
        if(spotifyId == null){
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Spotify ID required to generate rationale");
        }

        var track = spotifyservice.getTrack(spotifyId);
        String trackName = track.hasNonNull("name") ? track.get("name").asText() : "this song";

        String rationale = geminiservice.generate(
                "In 1-2 sentences, explain why someone might enjoy the song \""
                        + trackName + "\"."
        );

        //clean up escape characters or formatting issues
        rationale = rationale.replace("\\\"", "\"")
                .replace("\\n", " ")
                .replace("\\", "")
                .trim();

        r.setRationale(rationale);
        r.setSource(Recommendation.RecSource.GEMINI_GENERATED);
    }

    /**
     *  DISCOVER (GET) - Returns recommended tracks for the logged-in user using
     *  Spotify + Gemini pipeline
     * @param session containing "uid"
     * @return list of TrackDTOs for recommended tracks
     */
    @GetMapping("/suggestions")
    public List<SuggestedTrackResponse> getSuggestedTracks(HttpSession session){
        Integer uid = getSessionUid(session);

        User user = userrepository.findById(uid)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "User not found"));

        if(user.getSpotifyAccessToken() == null || user.getSpotifyAccessToken().isBlank()){
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Spotify account not linked ");
        }

        return recservice.discoverRecommendations(user);
    }


}

